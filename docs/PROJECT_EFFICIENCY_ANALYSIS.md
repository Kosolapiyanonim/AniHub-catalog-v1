# Анализ эффективности проекта AniHub (структурированный)

## 1) TL;DR (сжатый вывод)

**Интегральная оценка текущей эффективности: 7.2 / 10.**

Проект уже имеет сильную архитектурную базу (Next.js App Router + Supabase + API-слой + RSC), но теряет эффективность в 4 зонах:

1. **Стабильность CI/CD** — `pnpm build` падает из-за сетевой зависимости от Google Fonts.
2. **Качество фронтенд-слоя** — `pnpm lint` падает на ошибке `react/no-unescaped-entities`.
3. **Операционная эффективность** — заметный dependency bloat в `package.json` (пакеты экосистем Svelte/Vue/Remix без признаков использования).
4. **Наблюдаемость и KPI** — нет явной фиксации baseline-метрик производительности и delivery-метрик.

---

## 2) Снимок текущего состояния (baseline)

### Кодовая база
- TypeScript/TSX-файлов: **163**.
- API routes (`app/api`): **22**.
- UI-компонентов (`components/ui`): **58**.
- TODO/FIXME/HACK-маркеров: **1**.

### Проверки
- `pnpm lint`: **не проходит**.
  - Ошибка в `app/test/page.tsx` (`react/no-unescaped-entities`).
  - Предупреждения о `<img>` в `components/mobile-menu-content.tsx`.
- `pnpm build`: **не проходит**.
  - Ошибка загрузки Google Fonts (`Inter`, `Space Grotesk`) в `app/layout.tsx`.

---

## 3) Эффективность по доменам (scorecard)

| Домен | Оценка | Почему так | Риск |
|---|---:|---|---|
| Архитектура | 8.5/10 | Разделение по слоям (UI, hooks, lib, API), App Router, серверный и клиентский рендеринг | Средний |
| Производительность runtime | 7.5/10 | RSC и API-агрегации помогают, но есть технические риски (оптимизация изображений/шрифтов) | Средний |
| DevEx/Скорость разработки | 6.5/10 | Большой проект с понятной структурой, но lint/build не зелёные → замедление поставки | Высокий |
| Надёжность сборки | 5.5/10 | Build зависит от внешней сети для шрифтов | Высокий |
| Управление зависимостями | 5.0/10 | Вероятный избыток зависимостей (Svelte/Vue/Remix/Vite в Next.js-проекте) | Средний |
| Тестируемость | 5.5/10 | E2E конфиг есть, но тестов мало (1 файл) | Средний |
| Поддерживаемость | 7.0/10 | Много документации и модулей, но нет формализованных KPI по эффективности | Средний |

---

## 4) План улучшения по этапам

## Этап 0 — Быстрые победы (1–2 дня)
**Цель:** вернуть «зелёный» базовый пайплайн.

1. Исправить lint-ошибки в `app/test/page.tsx`.
2. Убрать сетевую хрупкость build для шрифтов:
   - либо локализовать шрифты,
   - либо добавить fallback-стратегию/кэширование.
3. Вынести критические проверки в CI как обязательные: `lint`, `build`.

**KPI этапа:**
- `lint` = pass.
- `build` = pass (без внешней нестабильности).
- MTTR по красному пайплайну < 2 часов.

## Этап 1 — Оптимизация затрат разработки (2–4 дня)
**Цель:** ускорить установку/сборку и уменьшить «шум» зависимостей.

1. Провести dependency audit и удалить неиспользуемые пакеты.
2. Зафиксировать политику версионирования (избегать повсеместного `latest` для воспроизводимости).
3. Внедрить регулярную проверку «лишних» зависимостей в CI.

**KPI этапа:**
- Снижение количества direct dependencies минимум на 15–25%.
- Снижение времени `pnpm install`/`pnpm build` (базлайн + Δ).

## Этап 2 — Качество продукта и производительность (1–2 недели)
**Цель:** улучшить UX и техническое качество.

1. Планомерно заменить критичные `<img>` на `next/image` там, где это влияет на LCP.
2. Провести audit маршрутов с самой высокой нагрузкой (`/catalog`, `/anime/[id]`, `/api/catalog`).
3. Добавить измерение Core Web Vitals и API latency (P50/P95/P99).

**KPI этапа:**
- LCP на ключевых страницах ≤ 2.5с (целевой диапазон).
- Снижение P95 времени ответа API минимум на 20% (по нагруженным эндпоинтам).

## Этап 3 — Надёжность и масштабирование (2–4 недели)
**Цель:** создать устойчивую инженерную систему.

1. Расширить покрытие e2e/smoke-кейсов (auth, catalog filters, anime page, comments).
2. Добавить SLO/SLA и алерты (ошибки API, деградация latency, падение парсера).
3. Формализовать релизные checklists и регресс-сценарии.

**KPI этапа:**
- Smoke e2e на критический пользовательский путь перед каждым релизом.
- Failure rate релизов < 10%.

---

## 5) Сжатый формат контроля (операционная карта)

```yaml
project_efficiency:
  current_score: 7.2
  blockers:
    - lint_fails
    - build_network_font_dependency
  quick_wins:
    - fix_unescaped_entities
    - de-risk_fonts_in_build
    - enforce_ci_gates
  medium_term:
    - dependency_cleanup
    - remove_latest_version_policy
    - add_web_vitals_and_api_latency_baseline
  long_term:
    - expand_e2e_for_critical_flows
    - define_slo_and_release_checklists
  review_cadence:
    weekly: [lint_status, build_status, ci_duration, failed_deploys]
    biweekly: [dependencies_count, install_time, build_time]
    monthly: [lcp, p95_api_latency, release_failure_rate]
```

---

## 6) Что считать «эффективным» через 30 дней

Проект можно считать заметно более эффективным, если одновременно выполняются условия:

1. Базовый pipeline стабилен (`lint`, `build`) и проходит постоянно.
2. Уменьшен объём нерелевантных зависимостей и повышена воспроизводимость сборки.
3. Есть baseline метрик (LCP, API latency, CI duration) и трекинг динамики.
4. Есть минимальный, но надёжный e2e smoke-набор на критический пользовательский сценарий.
