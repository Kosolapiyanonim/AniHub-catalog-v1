-- ============================================================================
-- AniHub Database Schema
-- Выполнить в Supabase SQL Editor (Dashboard -> SQL Editor -> New Query)
-- ============================================================================
--
-- ИНСТРУКЦИЯ:
-- 1. Для НОВОЙ базы данных - просто выполните весь скрипт
-- 2. Для СУЩЕСТВУЮЩЕЙ базы с данными - используйте миграцию (см. ниже)
-- 3. Для ПЕРЕСОЗДАНИЯ всех таблиц (удалит все данные!) - раскомментируйте
--    секцию "ПЕРЕСОЗДАНИЕ ТАБЛИЦ" ниже
-- ============================================================================

-- Включаем расширение для полнотекстового поиска
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- ============================================================================
-- ПЕРЕСОЗДАНИЕ ТАБЛИЦ (раскомментируйте, если нужно пересоздать таблицы)
-- ВНИМАНИЕ: Это удалит ВСЕ данные из таблиц!
-- ============================================================================

DROP TABLE IF EXISTS comments CASCADE;
DROP TABLE IF EXISTS user_subscriptions CASCADE;
DROP TABLE IF EXISTS user_lists CASCADE;
DROP TABLE IF EXISTS anime_relations CASCADE;
DROP TABLE IF EXISTS translations CASCADE;
DROP TABLE IF EXISTS anime_countries CASCADE;
DROP TABLE IF EXISTS anime_tags CASCADE;
DROP TABLE IF EXISTS anime_studios CASCADE;
DROP TABLE IF EXISTS anime_genres CASCADE;
DROP TABLE IF EXISTS countries CASCADE;
DROP TABLE IF EXISTS tags CASCADE;
DROP TABLE IF EXISTS studios CASCADE;
DROP TABLE IF EXISTS genres CASCADE;
DROP TABLE IF EXISTS animes CASCADE;
DROP VIEW IF EXISTS animes_with_details;


-- ============================================================================
-- 1. ОСНОВНАЯ ТАБЛИЦА animes
-- ============================================================================
CREATE TABLE IF NOT EXISTS animes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  kodik_id TEXT UNIQUE,
  shikimori_id TEXT UNIQUE,
  kinopoisk_id TEXT,
  title TEXT NOT NULL,
  title_orig TEXT,
  year INT,
  poster_url TEXT,
  player_link TEXT,
  description TEXT,
  type TEXT,
  anime_kind TEXT,
  status TEXT,
  episodes_count INT DEFAULT 0,
  episodes_aired INT DEFAULT 0,
  episodes_total INT DEFAULT 0,
  rating_mpaa TEXT,
  kinopoisk_rating NUMERIC(3, 1),
  imdb_rating NUMERIC(3, 1),
  shikimori_rating NUMERIC(3, 1),
  kinopoisk_votes INT,
  shikimori_votes INT,
  weighted_rating NUMERIC(5, 3) DEFAULT 0,
  is_featured_in_hero BOOLEAN DEFAULT FALSE,
  hero_position INTEGER,
  hero_custom_image_url TEXT,
  screenshots JSONB DEFAULT '[]'::jsonb,
  ts_document TSVECTOR,
  updated_at_kodik TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Индексы для animes
CREATE INDEX IF NOT EXISTS idx_animes_shikimori_id ON animes(shikimori_id);
CREATE INDEX IF NOT EXISTS idx_animes_year ON animes(year);
CREATE INDEX IF NOT EXISTS idx_animes_status ON animes(status);
CREATE INDEX IF NOT EXISTS idx_animes_type ON animes(type);
CREATE INDEX IF NOT EXISTS idx_animes_anime_kind ON animes(anime_kind);
CREATE INDEX IF NOT EXISTS idx_animes_weighted_rating ON animes(weighted_rating);
CREATE INDEX IF NOT EXISTS idx_animes_updated_at_kodik ON animes(updated_at_kodik);
CREATE INDEX IF NOT EXISTS idx_animes_shikimori_rating ON animes(shikimori_rating);
CREATE INDEX IF NOT EXISTS idx_animes_shikimori_votes ON animes(shikimori_votes);
CREATE INDEX IF NOT EXISTS idx_animes_ts_document ON animes USING GIN(ts_document);

-- Функция для обновления ts_document (полнотекстовый поиск)
CREATE OR REPLACE FUNCTION update_animes_tsvector() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.ts_document := to_tsvector('russian', coalesce(NEW.title, '') || ' ' || coalesce(NEW.title_orig, '') || ' ' || coalesce(NEW.description, ''));
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS tr_update_anime_tsvector ON animes;
CREATE TRIGGER tr_update_anime_tsvector
BEFORE INSERT OR UPDATE ON animes
FOR EACH ROW
EXECUTE FUNCTION update_animes_tsvector();

-- ============================================================================
-- 2. СПРАВОЧНИКИ (genres, studios, tags, countries)
-- ============================================================================
CREATE TABLE IF NOT EXISTS genres (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  slug TEXT UNIQUE
);

CREATE TABLE IF NOT EXISTS studios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  slug TEXT UNIQUE
);

CREATE TABLE IF NOT EXISTS tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  slug TEXT UNIQUE
);

CREATE TABLE IF NOT EXISTS countries (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);

-- ============================================================================
-- 3. СВЯЗУЮЩИЕ ТАБЛИЦЫ
-- ============================================================================
CREATE TABLE IF NOT EXISTS anime_genres (
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  genre_id BIGINT NOT NULL REFERENCES genres(id) ON DELETE CASCADE,
  PRIMARY KEY (anime_id, genre_id)
);
CREATE INDEX IF NOT EXISTS idx_anime_genres_genre ON anime_genres(genre_id);

CREATE TABLE IF NOT EXISTS anime_studios (
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  studio_id BIGINT NOT NULL REFERENCES studios(id) ON DELETE CASCADE,
  PRIMARY KEY (anime_id, studio_id)
);
CREATE INDEX IF NOT EXISTS idx_anime_studios_studio ON anime_studios(studio_id);

CREATE TABLE IF NOT EXISTS anime_tags (
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  PRIMARY KEY (anime_id, tag_id)
);
CREATE INDEX IF NOT EXISTS idx_anime_tags_tag ON anime_tags(tag_id);

CREATE TABLE IF NOT EXISTS anime_countries (
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  country_id BIGINT NOT NULL REFERENCES countries(id) ON DELETE CASCADE,
  PRIMARY KEY (anime_id, country_id)
);
CREATE INDEX IF NOT EXISTS idx_anime_countries_country ON anime_countries(country_id);

-- ============================================================================
-- 4. ОЗВУЧКИ (translations)
-- ============================================================================
CREATE TABLE IF NOT EXISTS translations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  kodik_translation_id INTEGER NOT NULL,
  title TEXT,
  type TEXT,
  quality TEXT,
  player_link TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (anime_id, kodik_translation_id)
);
CREATE INDEX IF NOT EXISTS idx_translations_anime ON translations(anime_id);

-- ============================================================================
-- 5. СВЯЗАННЫЕ АНИМЕ (anime_relations)
-- ============================================================================
CREATE TABLE IF NOT EXISTS anime_relations (
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  related_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  relation_type TEXT,
  relation_type_formatted TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (anime_id, related_id)
);
CREATE INDEX IF NOT EXISTS idx_anime_relations_related ON anime_relations(related_id);

-- ============================================================================
-- 6. ПОЛЬЗОВАТЕЛЬСКИЕ ТАБЛИЦЫ
-- ============================================================================
CREATE TABLE IF NOT EXISTS user_lists (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  status TEXT NOT NULL,
  progress INT DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, anime_id)
);
CREATE INDEX IF NOT EXISTS idx_user_lists_user ON user_lists(user_id);
CREATE INDEX IF NOT EXISTS idx_user_lists_status ON user_lists(user_id, status);

CREATE TABLE IF NOT EXISTS user_subscriptions (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, anime_id)
);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_user ON user_subscriptions(user_id);

CREATE TABLE IF NOT EXISTS comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  anime_id BIGINT NOT NULL REFERENCES animes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_comments_anime ON comments(anime_id);

-- ============================================================================
-- 7. VIEW для каталога
-- ============================================================================
CREATE OR REPLACE VIEW animes_with_details AS
SELECT * FROM animes;

-- ============================================================================
-- 8. RLS ПОЛИТИКИ
-- ============================================================================

-- Включаем RLS на всех таблицах
ALTER TABLE animes ENABLE ROW LEVEL SECURITY;
ALTER TABLE genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE studios ENABLE ROW LEVEL SECURITY;
ALTER TABLE tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE countries ENABLE ROW LEVEL SECURITY;
ALTER TABLE anime_genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE anime_studios ENABLE ROW LEVEL SECURITY;
ALTER TABLE anime_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE anime_countries ENABLE ROW LEVEL SECURITY;
ALTER TABLE translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE anime_relations ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_lists ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- Политики для animes
-- ============================================================================
DROP POLICY IF EXISTS "public_read_animes" ON animes;
CREATE POLICY "public_read_animes" ON animes FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_animes" ON animes;
CREATE POLICY "service_write_animes" ON animes FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для genres
-- ============================================================================
DROP POLICY IF EXISTS "public_read_genres" ON genres;
CREATE POLICY "public_read_genres" ON genres FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_genres" ON genres;
CREATE POLICY "service_write_genres" ON genres FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для studios
-- ============================================================================
DROP POLICY IF EXISTS "public_read_studios" ON studios;
CREATE POLICY "public_read_studios" ON studios FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_studios" ON studios;
CREATE POLICY "service_write_studios" ON studios FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для tags
-- ============================================================================
DROP POLICY IF EXISTS "public_read_tags" ON tags;
CREATE POLICY "public_read_tags" ON tags FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_tags" ON tags;
CREATE POLICY "service_write_tags" ON tags FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для countries
-- ============================================================================
DROP POLICY IF EXISTS "public_read_countries" ON countries;
CREATE POLICY "public_read_countries" ON countries FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_countries" ON countries;
CREATE POLICY "service_write_countries" ON countries FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для anime_genres
-- ============================================================================
DROP POLICY IF EXISTS "public_read_anime_genres" ON anime_genres;
CREATE POLICY "public_read_anime_genres" ON anime_genres FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_anime_genres" ON anime_genres;
CREATE POLICY "service_write_anime_genres" ON anime_genres FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для anime_studios
-- ============================================================================
DROP POLICY IF EXISTS "public_read_anime_studios" ON anime_studios;
CREATE POLICY "public_read_anime_studios" ON anime_studios FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_anime_studios" ON anime_studios;
CREATE POLICY "service_write_anime_studios" ON anime_studios FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для anime_tags
-- ============================================================================
DROP POLICY IF EXISTS "public_read_anime_tags" ON anime_tags;
CREATE POLICY "public_read_anime_tags" ON anime_tags FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_anime_tags" ON anime_tags;
CREATE POLICY "service_write_anime_tags" ON anime_tags FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для anime_countries
-- ============================================================================
DROP POLICY IF EXISTS "public_read_anime_countries" ON anime_countries;
CREATE POLICY "public_read_anime_countries" ON anime_countries FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_anime_countries" ON anime_countries;
CREATE POLICY "service_write_anime_countries" ON anime_countries FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для translations
-- ============================================================================
DROP POLICY IF EXISTS "public_read_translations" ON translations;
CREATE POLICY "public_read_translations" ON translations FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_translations" ON translations;
CREATE POLICY "service_write_translations" ON translations FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для anime_relations
-- ============================================================================
DROP POLICY IF EXISTS "public_read_anime_relations" ON anime_relations;
CREATE POLICY "public_read_anime_relations" ON anime_relations FOR SELECT USING (true);

DROP POLICY IF EXISTS "service_write_anime_relations" ON anime_relations;
CREATE POLICY "service_write_anime_relations" ON anime_relations FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- Политики для user_lists (только владелец)
-- ============================================================================
DROP POLICY IF EXISTS "user_lists_select_owner" ON user_lists;
CREATE POLICY "user_lists_select_owner" ON user_lists FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_lists_insert_owner" ON user_lists;
CREATE POLICY "user_lists_insert_owner" ON user_lists FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_lists_update_owner" ON user_lists;
CREATE POLICY "user_lists_update_owner" ON user_lists FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_lists_delete_owner" ON user_lists;
CREATE POLICY "user_lists_delete_owner" ON user_lists FOR DELETE USING (auth.uid() = user_id);

-- ============================================================================
-- Политики для user_subscriptions (только владелец)
-- ============================================================================
DROP POLICY IF EXISTS "user_subscriptions_select_owner" ON user_subscriptions;
CREATE POLICY "user_subscriptions_select_owner" ON user_subscriptions FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_subscriptions_insert_owner" ON user_subscriptions;
CREATE POLICY "user_subscriptions_insert_owner" ON user_subscriptions FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_subscriptions_update_owner" ON user_subscriptions;
CREATE POLICY "user_subscriptions_update_owner" ON user_subscriptions FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_subscriptions_delete_owner" ON user_subscriptions;
CREATE POLICY "user_subscriptions_delete_owner" ON user_subscriptions FOR DELETE USING (auth.uid() = user_id);

-- ============================================================================
-- Политики для comments
-- ============================================================================
DROP POLICY IF EXISTS "comments_select_all" ON comments;
CREATE POLICY "comments_select_all" ON comments FOR SELECT USING (true);

DROP POLICY IF EXISTS "comments_insert_own" ON comments;
CREATE POLICY "comments_insert_own" ON comments FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "comments_update_own" ON comments;
CREATE POLICY "comments_update_own" ON comments FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "comments_delete_own" ON comments;
CREATE POLICY "comments_delete_own" ON comments FOR DELETE USING (auth.uid() = user_id);

-- ============================================================================
-- ГОТОВО! Схема создана.
-- ============================================================================
--
-- ПРОВЕРКА:
-- Если таблица animes уже существовала и в ней нет некоторых колонок
-- (например, weighted_rating, anime_kind, episodes_aired, episodes_total),
-- то выполните следующую команду для проверки структуры:
--
-- SELECT column_name, data_type 
-- FROM information_schema.columns 
-- WHERE table_name = 'animes' 
-- ORDER BY ordinal_position;
--
-- Если колонок не хватает, раскомментируйте секцию "ПЕРЕСОЗДАНИЕ ТАБЛИЦ"
-- в начале скрипта и выполните скрипт заново (ВНИМАНИЕ: это удалит все данные!)
-- ============================================================================
