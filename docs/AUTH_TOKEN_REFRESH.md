# Руководство по обновлению JWT токенов

## Проблема

JWT access token истекает через ~1 час. Без автоматического обновления пользователи теряют доступ к защищенным функциям, даже если у них есть валидный refresh token.

## Решение: Гибридный подход (getUser + getSession)

### `getAuthenticatedUser()` - ИСПОЛЬЗУЙТЕ для критичных операций

**Что делает:**
- Сначала использует `getUser()` для проверки подлинности токена через Supabase Auth сервер (устраняет предупреждение о безопасности)
- Если токен истек, автоматически использует `getSession()` для обновления токена
- Возвращает `User | null`
- Пользователь остается авторизованным даже после истечения access token
- **Устраняет предупреждение Supabase о небезопасном использовании getSession()**

**Когда использовать:**
- ✅ API routes, где требуется аутентификация
- ✅ Операции, которые пользователь должен иметь возможность выполнять (комментирование, добавление в списки, обновление профиля)
- ✅ Все критичные операции, требующие проверки подлинности

**Пример:**
```typescript
import { getAuthenticatedUser } from "@/lib/supabase/server"

const response = new NextResponse()
const supabase = await createClientForRouteHandler(response)
const user = await getAuthenticatedUser(supabase)
if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401, headers: response.headers })
```

### `getUser()` - ИСПОЛЬЗУЙТЕ для опциональных проверок

**Что делает:**
- Только проверяет токен, НЕ обновляет его
- Если токен истек, возвращает ошибку "JWT expired"
- Быстрее, но не обновляет токены

**Когда использовать:**
- ✅ Опциональные проверки пользователя (например, для персонализации контента)
- ✅ Места, где ошибка аутентификации обрабатывается gracefully
- ✅ Публичные endpoints, где пользователь опционален

**Пример:**
```typescript
try {
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error && error.message?.includes('JWT')) {
    // JWT expired - игнорируем, работаем без пользователя
    console.log("JWT expired, continuing without user")
  } else if (user) {
    // Пользователь авторизован
  }
} catch (error) {
  // Игнорируем ошибки авторизации
}
```

## Где используется безопасная аутентификация

### ✅ Критичные места (используют getAuthenticatedUser()):

1. **middleware.ts**
   - Автоматически обновляет токены на каждом запросе (использует `getSession()` для обновления без проверки)

2. **app/api/comments/route.ts**
   - `POST` - создание комментариев (использует `getAuthenticatedUser()`)
   - `DELETE` - удаление комментариев (использует `getAuthenticatedUser()`)

3. **app/api/profile/route.ts**
   - `GET` - получение профиля (может создавать профиль для текущего пользователя, использует `getAuthenticatedUser()` опционально)
   - `PATCH` - обновление профиля (использует `getAuthenticatedUser()`)

4. **app/api/lists/route.ts**
   - `POST` - добавление/удаление аниме из списков (использует `getAuthenticatedUser()`)

5. **app/api/subscriptions/route.ts**
   - `POST` - подписка/отписка на аниме (использует `getAuthenticatedUser()`)
   - `GET` - проверка статуса подписки (использует `getAuthenticatedUser()`)

### ⚠️ Опциональные места (используют getUser()):

1. **app/api/catalog/route.ts**
   - Опциональная проверка для фильтрации по спискам пользователя
   - Ошибка обрабатывается gracefully, работает без пользователя

2. **app/api/anime/[id]/route.ts**
   - Опциональная проверка для получения статуса в списке пользователя
   - Ошибка обрабатывается gracefully, работает без пользователя

3. **app/api/homepage-sections/route.ts**
   - Опциональная проверка для персонализированных секций
   - Работает без пользователя, показывает публичный контент

## Обработка ошибок на клиенте

В хуках и компонентах нужно обрабатывать ошибку 401 (Unauthorized):

```typescript
if (response.status === 401) {
  toast.error("Сессия истекла. Пожалуйста, обновите страницу и попробуйте снова.");
  window.location.reload(); // Обновляем страницу для обновления токенов
  return;
}
```

## Автоматическое обновление на клиенте

В `components/supabase-provider.tsx` настроено автоматическое обновление сессии каждые 50 минут (до истечения через 1 час).

## Итоговая таблица

| Место | Метод | Причина |
|-------|-------|---------|
| middleware.ts | `getSession()` | Автоматическое обновление на каждом запросе (без проверки подлинности) |
| API: comments (POST/DELETE) | `getAuthenticatedUser()` | Критичная операция, безопасная проверка + обновление токенов |
| API: profile (GET/PATCH) | `getAuthenticatedUser()` | Критичная операция, безопасная проверка + обновление токенов |
| API: lists (POST) | `getAuthenticatedUser()` | Критичная операция, безопасная проверка + обновление токенов |
| API: subscriptions (POST/GET) | `getAuthenticatedUser()` | Критичная операция, безопасная проверка + обновление токенов |
| API: catalog (GET) | `getUser()` | Опционально, ошибка обрабатывается |
| API: anime/[id] (GET) | `getUser()` | Опционально, ошибка обрабатывается |
| API: homepage-sections (GET) | `getUser()` | Опционально, работает без пользователя |

## Правило большого пальца

**Используйте `getAuthenticatedUser()` если:**
- Операция требует аутентификации
- Пользователь должен иметь возможность выполнить действие даже при истечении access token
- Это критичная операция (создание, обновление, удаление данных)
- Нужна безопасная проверка подлинности токена

**Используйте `getUser()` если:**
- Проверка пользователя опциональна
- Ошибка аутентификации обрабатывается gracefully
- Endpoint работает и без пользователя
- Не требуется автоматическое обновление токенов

**Используйте `getSession()` только в middleware:**
- Для автоматического обновления токенов на каждом запросе
- Без проверки подлинности (это делается в API routes через `getAuthenticatedUser()`)

## Безопасность

`getAuthenticatedUser()` решает проблему предупреждения Supabase о небезопасном использовании `getSession()`:
- ✅ Сначала проверяет токен через `getUser()` (безопасно)
- ✅ При истечении токена использует `getSession()` для обновления
- ✅ Гарантирует подлинность данных пользователя
- ✅ Сохраняет автоматическое обновление токенов

